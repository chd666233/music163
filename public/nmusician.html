<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="css/base.css">
  <link rel="stylesheet" href="css/nmusician.css">
  <link rel="stylesheet" href="css/nmusician_index.css">
  <script src="js/jquery-1.11.3.js"></script>
</head>
<body class="nmusician">
  <header id="header">
    <nav>
      <a href="#" class="logo">网易音乐人</a>
      <ul class="page">
        <li class="active"><a href="#">首页</a></li>
        <li><a href="#" class="z-stone-plan-online">石头计划</a></li>
        <li><a href="#">个人中心</a></li>
        <li><a href="#">常见问题</a></li>
      </ul>
    
      <ul class="user">
        <li><a href="#" class="joinUs">加入音乐人</a></li>
        <li>您还未登陆，请先<a href="#" class="login">登陆</a></li>
      </ul>
    </nav>
  </header>
  <!-- <iframe name="contentFrame" src="nmusician_index.html" frameborder="0" scrolling="no"></iframe> -->

  <section>
    <ul id="floor" class="floor">
      <li class="floor1">
        <img src="img/nmusician_1.png" alt="">
        <p class="joinUs">
          <a href="#">现在加入</a>
          <a href="#">I'm Not Chinese Artist ></a>
        </p>
        <div class="btn">
          <a href="#"></a>
          <a href="#"></a>
          <a href="#"></a>
        </div>
      </li>
      <li class="floor2">
        <div class="box">
          <h1>自助式作品管理</h1>
          <div>
            <div class="content">
              <img src="img/nmusician_2_1.png" alt="">
              <h3>绿色通道，快速发布</h3>
              <p>专属上传通道，发布即上线，<br>
                  让您的作品第一时间和粉丝见面</p>
            </div>
            <div class="content">
              <img src="img/nmusician_2_2.png" alt="">
              <h3>透明、直观的数据报表</h3>
              <p>每日更新作品数据、粉丝数据，<br>
                  帮助您更好的运营自己</p>
            </div>
            <div class="content">
              <img src="img/nmusician_2_3.png" alt="">
              <h3>简单易用的作品管理</h3>
              <p>从封面、曲风到歌词编辑，<br>
                  强大又好用的作品管理</p>
            </div>
          </div>
        </div>
      </li>
      <li class="floor3">
        <div class="box">
          <h1 class="dark">多维度曝光</h1>
          <p class="desc dark">您安心做好音乐，剩下的交给我们</p>
          <div class="content">
            <div class="box_ul">
              <ul id="floor3_ul" class="floor3_ul">
                <li>
                  <img src="img/zhaolei.jpg" alt="">
                </li>
                <li>
                  <img src="img/luodi.jpg" alt="">
                </li>
                <li>
                  <img src="img/duli.jpg" alt="">
                </li>
                <li>
                  <img src="img/lizhi.jpg" alt="">
                </li>
                <li>
                  <img src="img/shitoujihua.jpg" alt="">
                </li>
              </ul>
            </div>
            
            <span class="prev"></span>
            <span class="next"></span>
          </div>
        </div>
      </li>
      <li class="floor4">
        <div class="box">
          <h1>丰富的变现模式</h1>
          <p class="desc">除了加入会员项目、售卖数字专辑外，您还可以通过开通赞赏、售卖周边获取额外收入</p>
          <div class="content">
            <div class="cover">陈粒</div>
            <p>专辑累计销量227785张</p>
          </div>
          <div class="content">
            <div class="cover">李志</div>
            <p>专辑累计销量303196张</p>
          </div>
          <div class="content">
            <div class="cover">好妹妹</div>
            <p>专辑累计销量127765张</p>
          </div>
        </div>
      </li>
     
    </ul>
    <ul id="indicator" class="indicator"></ul>
  </section>
  <script>
    /*  1.为了能够在鼠标在ul或li上依然滚动，把滚动事件绑定在了document上
        2.为了能够在滚动后鼠标如果还在li上能滚动回去，用了 
        if(isOver){
              mOverHandler.call(cLi,eV)
        }
        3.为了当鼠标移到li上即使还没有到达目标也能在到达目标后滚动到li位置，用了setTimeout 700ms
          同时700ms到达前从li上移开了，用了mouseouter clearTimeout
        4.ulT和targetT不同步，因为ulT在其他地方重新赋值了，所以下面重新给ulT赋值
        if(timeOut_overing) clearTimeout(timeOut_overing);
        timeOut_overing=setTimeout(()=>{
          ulT=parseFloat(getComputedStyle(floor).top);//为什么要重新获取？因为在wheelHandler中重新给ulT赋值了，ulT和targetT并不完全同步，但是targetT代表的是目标位置
          console.log("##################",ulT,targetT,viewH)
          if(ulT-targetT<2&&ulT-targetT>-2){//移动到目标位置后
            floor.style.cssText=`transition:none;top:${targetT}px`;
          }
        },1000)
        5. 鼠标over在li并且li不是active的时候不滚动，这样鼠标over在里上就不会一直滚动底部，可以去掉试试效果
      if(isOver&&e.target.className!='active') return;
    */
  "use strict";
  (function(){
    // 判断浏览器类型
    var isMacWebkit=(navigator.userAgent.indexOf("Macintosh")!==-1&&navigator.userAgent.indexOf("WebKit")!==-1);
    var isFirefox=(navigator.userAgent.indexOf("Gecko")!==-1);
    //获取需要的节点
    var header=document.getElementById("header");
    var floor=document.getElementById("floor");
    var indicator=document.getElementById("indicator");
    var fragment=document.createDocumentFragment();
    var length=floor.querySelectorAll(".floor>li").length;
    var viewH=innerHeight;

    //动态添加指示器
    for(var i=0;i<length;i++){
      var li=document.createElement("LI");
      if(i==0) li.className="active";
      li.setAttribute("data-index",i);
      fragment.appendChild(li);
    }
    indicator.appendChild(fragment);
    var lis=indicator.getElementsByTagName("LI");
    
    
     //初始化事件处理函数参数
    var targetT=0,
        index=0,
        ulT=0,
        timeOut_wheel=null,//mousewheel
        timeOut_wheel2=null,
        timeOut_overing,//mouseover
        timeOut_overing2,
        isOver=false,//鼠标是否over
        // isWheel=false,//鼠标是否wheel
        isArrive=false,
        timeOut_isArrive=null,
        prevTargetT,
        cLi=null,//触发over事件的li
        eV=null;//触发over事件的li的event对象
        
    

    //注册事件处理函数
    document.onwheel=wheelHandler;//FF未来浏览器
    document.onmousewheel=wheelHandler//大多数当前浏览器
    // document.addEventListener("mousewheel",wheelHandler);
    if(isFirefox)//仅FireFox，包括FF未来
      document.addEventListener("DOMMouseScroll",wheelHandler,false);
    //注册事件处理函数
    indicator.onmouseover=mOverHandler;
    indicator.onmouseout=function(){
      var e=event || window.event;//标准或IE事件对象
      if(e.target.nodeName!=='LI') return;
      isOver=false;
      if(timeOut_overing2) clearTimeout(timeOut_overing2);
      // floor.style.cssText=`transition:none;top:${targetT}px`;
      // clearTimeout(timeOut_overing)
    }


    function mOverHandler(event){
      var e=event || window.event;//标准或IE事件对象
      if(e.target.nodeName!=='LI') return;
      cLi=e.target,eV=e;
      isOver=true;
      
      // if(isWheel)return;
      
      //如果上一轮还没有滚动到目标位置，延迟滚动
      ulT=parseFloat(getComputedStyle(floor).top);
      // console.log("++++++++",index,targetT,ulT,[].indexOf.call(lis,e.target));
      var time=0;
      if(targetT!=ulT) {
        time=600;//延迟500ms
      }
      if(timeOut_overing2) clearTimeout(timeOut_overing2);
      timeOut_overing2=setTimeout(()=>{
        
        //1000ms没有over视为停止over,移动到目标位置后将渐变去掉，问题：有可能1000ms后还没有到达目标位置，
        //导致一次性定时器没有将渐变去掉，所以1000ms要根据渐变的时间（这里1s)来设置，确保到时间后已经到达目标位置
        if(timeOut_overing) clearTimeout(timeOut_overing);
        timeOut_overing=setTimeout(()=>{
          // console.log('--------------->',floor.offsetParent,floor.offsetTop)
          ulT=parseFloat(getComputedStyle(floor).top);//为什么要重新获取？因为在wheelHandler中重新给ulT赋值了，ulT和targetT并不完全同步，但是targetT代表的是目标位置
          // console.log("##################",ulT,targetT,viewH)
          if(ulT-targetT<2&&ulT-targetT>-2){//移动到目标位置后
            // console.log("##################",ulT,targetT,index)
            // console.log('--------------->',ulT,targetT,floor.offsetTop)
            floor.style.cssText=`transition:none;top:${targetT}px`;
          }
        },1000)

        var currenteInde=index;
        index=[].indexOf.call(lis,e.target);
        lis[currenteInde].className="";
        lis[index].className="active";
        targetT=ulT=-index*viewH;
       /*  if(prevTargetT!==undefined&&targetT!==prevTargetT){
          if(timeOut_isArrive) clearTimeout(timeOut_isArrive);
          timeOut_isArrive=setTimeout(()=>{
            floor.style.cssText=`transition:top 1s ease-in-out;top:${targetT}px`;
          },1000);
        }else{ */
          floor.style.cssText=`transition:top 1s ease-in-out;top:${targetT}px`;
       /*  }
        prevTargetT=targetT; */
        
        if(index==0)
          header.style.cssText="transition:background 1s;background:rgba(36, 36, 36, 0)";
        else
          header.style.cssText="transition:background 1s;background:rgb(36, 36, 36)";
      },time);
 
      
    }

    //事件处理函数
    function wheelHandler(event){
      //计算跨浏览器的deltaY
      var e=event || window.event;//标准或IE事件对象
     
     //鼠标over在li并且li不是active的时候不滚动，这样鼠标over在里上就不会一直滚动底部，可以去掉试试效果
      if(isOver&&e.target.className!='active') return;

       //鼠标停止滚动，取消渐变,这个放前面，否则被ruturn回去不执行
      if(timeOut_wheel) clearTimeout(timeOut_wheel);
      timeOut_wheel=setTimeout(function(){
        // console.log("&&&&&&&&&&&&&&--",ulT,targetT)
        // console.log('--------------->',floor.offsetParent,floor.offsetTop)
        // if(timeOut_wheel2) clearTimeout(timeOut_wheel2);
        ulT=parseFloat(getComputedStyle(floor).top);
        if(ulT==targetT){//移动到目标位置后
          // console.log("&&&&&&&&&&&&&&",ulT,targetT)
          floor.style.cssText=`transition:none;top:${targetT}px`;
        }
        // isWheel=false;
        if(isOver){
          mOverHandler.call(cLi,eV)
        }
      },1000)

      ulT=parseFloat(getComputedStyle(floor).top);//重新赋值，当前的ulT
      // var ulH=parseFloat(getComputedStyle(floor).height)*length;
      // console.log("-------------",index,targetT,ulT)

      //如果上一轮还没有滚动到目标位置，不执行这轮滚动
      var time=0;
      if(targetT!=ulT){
        time=700;
        return;
      };
      //不需要用定时器，没有意义
      // if(timeOut_wheel2) clearTimeout(timeOut_wheel2);
      // timeOut_wheel2=setTimeout(()=>{
        // isWheel=true;
        var deltaY=(e.deltaY!==null&&e.deltaY*-30)||//3级
                  (e.wheelDelta!==null&&e.wheelDelta/4)||//大部份浏览器
                  e.detail*-10||//FF
                  0;//未定义
        if(isMacWebkit){//如果是Mac,delta的值大120倍
          deltaY/=30;
        }
        //如果事件类型不是DOMMouseScroll就不再需要,因为如果FF未来版支持wheel或mousewheel会重复添加事件，需要去掉重复事件
        if(isFirefox && e.type!=="DOMMouseScroll")
          floor.removeEventListener("DOMMouseScroll",wheelHandler,false);

        
        if(deltaY>0){//向上滚动
          if(index==0)return;
          //滚动
          index--;
          lis[index+1].className="";
        }else{//向下滚动
          if(index==length-1) return;
          //滚动
          index++;
          lis[index-1].className="";
        }
        lis[index].className="active";
        if(index==0)
          header.style.cssText="transition:background 1s;background:rgba(36, 36, 36, 0)";
        else
          header.style.cssText="transition:background 1s;background:rgb(36, 36, 36)";
        targetT=ulT=-viewH*index;
        floor.style.cssText=`transition:top 1s ease-in-out;top:${ulT}px`;    
        

        //调用wheel事件上的preventDefault(),也能阻止mousewheel事件的产生
        if(e.preventDefault)e.preventDefault();
        if(e.stopPropagation)e.stopPropagation();
        e.cancelBubble=true;//IE事件  阻止冒泡
        e.returnValue=false;//IE事件
        return false;
      // },time);
      
    }
  })()
  
 
  </script>
</body>
</html>